Dorna(name, poses[] + ["unknown"]): {
    goal: {
        //name: domain (initial value)
        ref_pos: poses ("unknown")  //(..) initial
    },
    measured: {
        act_pos: poses ("unknown")
        failure: bool(false);  // how to reset?
    }
    estimated: {
        prev_pos: poses ("unknown")
    }

    abilities: {
        move_to: {
            //name: (pred_name:) pred / actions / [effects]
            // If enabled, execute, finished is not defined, maybe guess from common names of transitions?
            start: enabled: ref_pos == act_pos && !failure / prev_pos <- act_pos
            *dummy_t: enabled / prev_pos <- prev_pos
            *finished_effect: executing: ref_pos != act_pos / [act_pos <- ref_pos]  // _effect is just a name to make it easier to understand
            reset: error: failure / some reset actions / [!failure]
        }
    }

    specs: {
        cannot_go_to_unknown: ref_pos != "unknown"
    }

    messages: {
        //topic(message type): [variables] // variables can inlcude any path
        goal("robot_msgs/msg/RobotGoal"): [ref_pos], //  maybe only include variables not in goal? 
        measured("robot_msgs/msg/RobotState"): [act_pos, failure] // measured topic instead of state
    }
}

Camera(name): {
    goal: {
        do_scan: bool (false)
    },
    measured: {
        scanning: bool (false),
        done : bool (false),
        result : [0,1,2,3] (0)
    }
    abilities: {
        scan: {
            start: enabled: !do_scan && !scanning / do_scan
            *starting_effect: do_scan && !scanning / [scanning, !done]
            *finish_effect: executing: do_scan && scanning / [done, result?] // var? = the planner picks a value
            reset: finished: executing && done / !do_scan / [!done, !scanning, result <- 0]
        }
    }


    messages: {
        goal("camera_msgs/msg/Goal"): [ref_pos],
        measured("camera_msgs/msg/State"): [act_pos, failure] 
    }
}

Control_box(name): {
    goal: {
        blue_light: bool (false)
    },
    measured: {
        blue_light_on: bool (false),
    }

    abilities: {
        blue_on: {
            start: enabled: !blue_light_on / blue_light
            *finish_effect: executing: !blue_light_on && blue_light / [blue_light_on]
        }
        blue_off: {
            start: enabled: blue_light_on / !blue_light
            *finish_effect: executing: blue_light_on && !blue_light / [!blue_light_on]
        }
    }

    messages: {
        goal("control_box_msgs/msg/Goal"): [blue_light], 
        measured("control_box_msgs/msg/State"): [blue_light_on] 
    }
}


Cylinders_operations(): {
    r1 = Dorna(r1, [pre_take, scan, take1, take2, take3, leave])
    r2 = Dorna(r2, [pre_take, scan, take1, take2, take3, leave])
    cb = Control_box(cb)
    camera = Camera(c1)

    products = [0, 1, 2, 3, 100]
    variables: {
        shelf1: products (0)
        shelf2: products (0)
        shelf3: products (0)
        conv1: products (0)
        r1_holding: products (0)
    }

    specs: {
        r1_to_shelfs: r1.act_pos in [take1, take2, take3] 
                      => r1.prev_pos in [take1, take2, take3, pre_take]  // var in set == true

        r1_to_scan: r1.act_pos == scan  => r1.prev_pos in [scan, pre_take]
        r1_to_leave: r1.act_pos == leave  => r1.prev_pos in [leave, pre_take]

        r2_move1: r1.act_pos == scan => r2.act_pos == leave
        r2_move2: r1.act_pos == leave => r2.act_pos == scan

        // .* creates a new auto transition based (conjuncted) on the ability transition
        // also controlled - transition.ctrl: new guard / new actions / [new effects]
        cb.blue_on.start.*: r1.ref_pos == scan 
        // or maybe skipp .start
        cb.blue_off.start.*: r1.ref_pos != scan

        // conjuncted with existing ability transition guard (and actions and effects)
        camera.scan.start: r1.act_pos == scan
    }

    operations: {
        // loop?
        // must be controlled else will always leave when at pos
        // name: pre | post / post actions
        take_at_1: shelf1 != 0 && r1_holding == 0 | r1.act_pos == take1 / 
                    r1_holding <- shelf1, shelf1 <- 0
        take_at_2: shelf2 != 0 && r1_holding == 0 | r1.act_pos == take2 / 
                    r1_holding <- shelf2, shelf2 <- 0
        take_at_3: shelf3 != 0 && r1_holding == 0 | r1.act_pos == take3 / 
                    r1_holding <- shelf2, shelf3 <- 0
        take_at_conv1: conv1 != 0 && r1_holding == 0 | r1.act_pos == leave / 
                    r1_holding <- conv1, conv1 <- 0

        leave_at_1: shelf1 == 0 && r1_holding != 0 | r1.act_pos == take1 / 
                    shelf1 <- r1_holding, r1_holding <- 0
        leave_at_2: shelf2 == 0 && r1_holding != 0 | r1.act_pos == take2 / 
                    shelf2 <- r1_holding, r1_holding <- 0
        leave_at_3: shelf3 == 0 && r1_holding != 0 | r1.act_pos == take3 / 
                    shelf3 <- r1_holding, r1_holding <- 0
        leave_at_conv1: conv1 == 0 && r1_holding != 0 | r1.act_pos == leave / 
                    conv1 <- r1_holding, r1_holding <- 0

        scan:  r1_holding == 100 && camera.enabled | camera.done && camera.result != 0 /
                r1_holding <- camera.result

        sink_product: conv1 in [1, 2, 3] / conv1 <- 0
        source_product: conv1 == 0 / conv1 <- 100
        
    }
}

Cylinders(): {
    operations = Cylinders_operations()

    intentions: {
        identify_and_consume_parts: {
            pre: shelf1==100 && shelf2==100 && shelf3==100 && conv1!=100
            goal: shelf1==0 && shelf2==0 && shelf3==0 && r1_holding=0 && conv1==0
            inv:conv1!=100
            post: shelf1 <- 100 && shelf2 <- 100 && shelf3 <- 100
            reset: [identify_and_consume_parts]
        }
        get_new_ones: {
            pre: shelf1==0 && shelf2==0 && shelf3==0 
            goal: shelf1!=0 && shelf2!=0 && shelf3!=0 && r1_holding=0 && conv1==0
            reset: []
        }
        scan: {
            goal: shelf1 in [1,2,3] && shelf2 in [1,2,3] && shelf3 in [1,2,3]
            reset: []
        }

        get_and_scan: {
            get_new_ones, 
            scan
        }
    }

}





Cylinders2_operations(): {
    r1 = Dorna(r1, [pre_take, scan, take1, take1, take3, leave])
    r2 = Dorna(r2, [pre_take, scan, take1, take1, take3, leave])
    r3 = Dorna(r3, [pre_take, scan, leave])
    r4 = Dorna(r4, [pre_take, scan, leave])
    cb = Control_box(cb)
    camera = Camera(c1)

    products = [0, 1, 2, 3, 100]
    variables: {
        shelf1: products (0)
        shelf2: products (0)
        shelf3: products (0)
        conv1: products (0)
        conv2: products (0)
        r1_holding: products (0)
        r3_holding: products (0)
    }

    specs: {
        r1_to_shelfs: r1.act_pos in [take1, take2, take3] 
                      => r1.prev_pos in [take1, take2, take3, pre_take]  // var in set == true

        r1_to_scan: r1.act_pos == scan  => r1.prev_pos in [scan, pre_take]
        r1_to_leave: r1.act_pos == leave  => r1.prev_pos in [leave, pre_take]

        r2_move1: r1.act_pos == scan => r2.act_pos == leave
        r2_move2: r1.act_pos == leave => r2.act_pos == scan

        r3_only_new: r3.act_pos in [scan, leave, take3] => r3.prev_pos in [scan, leave, take3]

        cb.blue_on.start.*: r1.ref_pos == scan // blir en ny auto transition som plockar upp ability transition
        cb.blue_off.start.*: r1.ref_pos != scan

        camera.scan.start: r1.act_pos == scan // l√§gger till guard till befintlig ability trans

        conv2_no_unknown: conv2 != 100
    }

    operations: {
        r1_take_at_1: shelf1 != 0 && r1_holding == 0 | r1.act_pos == take1 / 
                    r1_holding <- shelf1, shelf1 <- 0
        r1_take_at_2: shelf2 != 0 && r1_holding == 0 | r1.act_pos == take2 / 
                    r1_holding <- shelf2, shelf2 <- 0
        r1_take_at_3: shelf3 != 0 && r1_holding == 0 | r1.act_pos == take3 / 
                    r1_holding <- shelf2, shelf3 <- 0
        r1_take_at_conv1: conv1 != 0 && r1_holding == 0 | r1.act_pos == leave / 
                    r1_holding <- conv1, conv1 <- 0

        r1_leave_at_1: shelf1 == 0 && r1_holding != 0 | r1.act_pos == take1 / 
                    shelf1 <- r1_holding, r1_holding <- 0
        r1_leave_at_2: shelf2 == 0 && r1_holding != 0 | r1.act_pos == take2 / 
                    shelf2 <- r1_holding, r1_holding <- 0
        r1_leave_at_3: shelf3 == 0 && r1_holding != 0 | r1.act_pos == take3 / 
                    shelf3 <- r1_holding, r1_holding <- 0
        r1_leave_at_conv1: conv1 == 0 && r1_holding != 0 | r1.act_pos == leave / 
                    conv1 <- r1_holding, r1_holding <- 0
        r1_leave_at_conv2: conv2 == 0 && r1_holding != 0 | r1.act_pos == leave / 
                    conv2 <- r1_holding, r1_holding <- 0

        scan:  r1_holding == 100 | camera.scan.finished /
                r1_holding <- camera.result[1,2,3], camera.scan.reset <- fire

        r3_take_conv1:  r3_holding == 0 && conv1 != 0 | r3.act_pos == take3 /
                        r3_holding <- conv1, conv1 <- 0
        r3_take_conv3:  r3_holding == 0 && conv3 != 0 | r3.act_pos == leave /
                        r3_holding <- conv3, conv3 <- 0
        r3_leave_conv1:  r3_holding != 0 && conv1 == 0 | r3.act_pos == take3 /
                        conv1 <- r3_holding, r3_holding <- 0
        r3_leave_conv3:  r3_holding != 0 && conv3 == 0 | r3.act_pos == leave /
                        conv3 <- r3_holding, r3_holding <- 0
        r3_to_scan: | r3.act_pos == scan

        source_product: conv1 == 0 && r3_holding == 0 | conv1 == 100 {
            r3_to_scan 
            source_part: r3_holding <- 100
            r3_leave_conv1
            r3_to_scan
        }
        sink_product: conv3 != 0 && r3_holding == 0 | conv3 <- 0 {
            r3_take_conv3
            r3_to_scan
            sink_part: r3_holding <- 0
        }
        // possible sop struct. Maybe hard to parse...
        name: guard / final result {
            op1
            op2 && op3 // parallell
            op4 || {   // alternative
                op5    // sequence in alternative
                op6
            }
        }
    }
}

Cylinders2(): {
    operations = Cylinders2_operations()

    intentions: {
        identify_and_consume_parts: {
            pre: shelf1==100 && shelf2==100 && shelf3==100 && conv1!=100
            goal: shelf1==0 && shelf2==0 && shelf3==0 && r1_holding=0 && conv1==0
            inv:conv1!=100
            post: shelf1 <- 100 && shelf2 <- 100 && shelf3 <- 100
            reset: true
        }
        get_new_ones: {
            pre: shelf1==0 && shelf2==0 && shelf3==0 
            goal: shelf1!=0 && shelf2!=0 && shelf3!=0 && r1_holding=0 && conv1==0
            reset: true
        }
        scan: {
            goal: shelf1 in [1,2,3] && shelf2 in [1,2,3] && shelf3 in [1,2,3]
            reset: true
        }

        get_and_scan: {
            get_new_ones, 
            scan
        }

        identify_types_r_g_b: {
            goal: shelf1 not in [0, 100 shelf2, shelf3] && 
                  shelf2 not in [0, 100 shelf1, shelf3] && 
                  shelf3 not in [0, 100 shelf1, shelf2]
            reset: true
        }
        identify_two_blue: {
            goal: shelf1 == 3 && shelf2 == 3 && shelf3 != 3 && 
                  shelf1 == 3 && shelf2 != 3 && shelf3 == 3 &&
                  shelf1 != 3 && shelf2 == 3 && shelf3 == 3
            reset: true
        }
        sort_shelves_r_g_b: {
            goal: shelf1 == 1 && shelf2 == 2 && shelf3 == 3 && 
            reset: true
        }


    }

}